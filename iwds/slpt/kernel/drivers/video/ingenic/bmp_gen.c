#include "bmp_logo.h"

#if BMP_LOGO_IN_UBOOT
#include <common.h>
#include <malloc.h>
#include <linux/string.h>
#include <linux/pr_info.h>
#else
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define pr_info(x...) printf(x)
#define pr_err(x...) fprintf (stderr, x)
#endif

enum bf_off{
	BF_TYPE_OFF = 0x00,
	BF_SIZE_OFF = 0x02,
	BF_OFFBITS_OFF = 0x0a,
	BI_SIZE_OFF = 0X0E,
	BI_WIDTH_OFF = 0X12,
	BI_HEIGHT_OFF = 0X16,
	BI_BITCOUNT_OFF = 0X1C,
	BI_COMPRESSION_OFF = 0X1E,
	BI_CLRUSED_OFF = 0X2E,
	BI_CLRIMPORTANT_OFF = 0X32,

};

enum bf_size{
	BF_TYPE_SIZE = 2,
	BF_SIZE_SIZE = 4,
	BF_OFFBITS_SIZE = 4,
	BI_SIZE_SIZE = 4,
	BI_WIDTH_SIZE = 4,
	BI_HEIGHT_SIZE = 4,
	BI_BITCOUNT_SIZE = 2,
	BI_COMPRESSION_SIZE = 4,
	BI_CLRUSED_SIZE = 4,
	BI_CLRIMPORTANT_SIZE = 4,

	BF_FILEHEADER_SIZE = 14,
};

static unsigned int BF_PALETTE_SIZE = 0;
static unsigned int BF_PALETTE_OFF = 0;
static unsigned int BI_INFOHEADER_SIZE = 40;

#define bmp_swap4(x) (x)

#define type_supported(type) (type == ('B' | 'M' << 8))

#define compression_supported(compression) (compression == 0)

#define info_supported(infosize) (infosize == BI_INFOHEADER_SIZE)

#define print_val(x) pr_info ("%s:\t0x%x \t%u\n",#x, (unsigned int)x,  (unsigned int)x)

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[1]))
#endif

#define to_line_len(width, bitcount) ((((width) * (bitcount) + 31) & ~31) / 8 )

inline void fill_data(unsigned char *filebuffer, unsigned int offset, unsigned int size, unsigned int *data) {
	*data = 0;
	memcpy(data, filebuffer + offset, size);
}

#define for_each_bmp_line(bmp, src, i, _height, line_len)				\
	for (i = 0, src = bmp->height > 0 ? bmp->databuffer + (_height - 1) * line_len : bmp->databuffer \
			 ; i < _height;												\
		 ++i, (bmp->height > 0 ? (src -= line_len) : (src += line_len)))

#if BMP_SUPPORT_FILE_OP
inline void skip_bytes(FILE *fp, int n) {
	while (n--)
		fgetc(fp);
}
#endif

#ifdef CONFIG_BMP_LOGO_AS_TOOL

static int gen_basic_hex = 0;
static int gen_bmp_header = 0, gen_bmp_data = 0;
static int gen_color_bin = 0, gen_color_header = 0, gen_color_data = 0;
static int gen_bmp_filebuffer = 0;

static unsigned int COLOR_BYTES = 4;

int usage(const char *prog) {
	pr_err( "Usage  ----  bmp_logo (%s) \n"
			"\tbmp_logo filename ...\n"
			"\t\tDefault to --gen-basic-hex option\n\n"
			"\t--gen-basic-hex(-gen-basic-hex)\n"
			"\t\tTo generate the basic hex info of this file\n\n"
			"\tWith following args can change the bmp file to color data\n\n"
			"\t--gen-color-header\n"
			"\t\tTo generate the framebuffer display colors header in C sytle\n\n"
			"\t--gen-color-data\n"
			"\t\tTo generate the framebuffer display colors in C sytle\n\n"
			"\t--gen-color-bin(-gen-color-bin)\n"
			"\t\tTo convert bmp file to framebuffer display colors (binary file)\n\n"
			"\t--color=num(-color=num)\n"
			"\t\tTo specific the color bits when use --gen-color-* option\n"
			"\t\tnum: 16 or 32\n\n"
			"\tWith following args can change the bmp file to C understand bmp struct data\n\n"
			"\t--gen-bmp-header(-gen-bmp-header)\n"
			"\t\tTo generate the bmp struct info header in C sytle\n\n"
			"\t--gen-bmp-data(-gen-bmp-data)\n"
			"\t\tTo generate the bmp image's display data in C sytle\n\n"
			"\n\tNOTE:\n"
			"\t\t DON'T make the --gen-color-bin with any other option together!!!\n",
			prog
		);

	return 0;
}

int bf_off_a[] = {
	BF_TYPE_OFF ,
	BF_SIZE_OFF ,
	BF_OFFBITS_OFF,
	BI_SIZE_OFF ,
	BI_WIDTH_OFF,
	BI_HEIGHT_OFF,
	BI_BITCOUNT_OFF,
	BI_COMPRESSION_OFF,
	BI_CLRUSED_OFF,
	BI_CLRIMPORTANT_OFF,
};

int bf_size_a[] = {
	BF_TYPE_SIZE,
	BF_SIZE_SIZE,
	BF_OFFBITS_SIZE,
	BI_SIZE_SIZE,
	BI_WIDTH_SIZE,
	BI_HEIGHT_SIZE,
	BI_BITCOUNT_SIZE,
	BI_COMPRESSION_SIZE,
	BI_CLRUSED_SIZE,
	BI_CLRIMPORTANT_SIZE,
};

char *bf_name_a[] = {
	"BF_TYPE",
	"BF_SIZE",
	"BF_OFFBITS",
	"BI_SIZE",
	"BI_WIDTH",
	"BI_HEIGHT",
	"BI_BITCOUNT",
	"BI_COMPRESSION",
	"BI_CLRUSED",
	"BI_CLRIMPORTANT",
};

void gen_basic_hex_info(unsigned char *filebuffer){
	unsigned char *p;
	int i, j;
	unsigned long long value;

	p = filebuffer;

	pr_info ("\nBMP header info \n");
	pr_info ("--------------------------------------------\n");
	for (i = 0; i < ARRAY_SIZE(bf_name_a); ++i) {
		p = filebuffer + bf_off_a[i];
		value = 0;
		for (j = 0; j < bf_size_a[i]; ++j) {
			value += p[j] << (j * 8);
		}
		pr_info ("0x%02X\t%s:(%llu)\t", bf_off_a[i], bf_name_a[i], value);
		for (j = 0; j < bf_size_a[i]; ++j) {
			pr_info ("0x%02X ", p[j]);
		}
		pr_info ("\n");
	}
	pr_info ("--------------------------------------------\n");
}

void gen_bmp_filebuffer_info(const unsigned char *filebuffer, unsigned long n) {
	unsigned long i;
	const unsigned char *p;

	p = filebuffer;
	pr_info ( "/*\n"
			  " * This is auto generated by tool bmp_logo\n"
			  " * If you don't know the details, don't edit it!\n"
			  " */\n"
			  "\n"
			  "#ifndef __BMP_FILEBUFFER__\n"
			  "#define __BMP_FILEBUFFER__\n"
			  "\n"
		);
	pr_info ("static unsigned char bmp_filebuffer[] = {\n");
	for (i = 0; i < n; ++i) {
		if (i % 8 == 0)
			pr_info ("%c",'\t');
		pr_info ("0x%02x,%c", *p++, (i % 8 == 7) ? '\n' : ' ');
	}
	pr_info ("\n};\n"
			 "\n#endif /* __BMP_FILEBUFFER__ */\n");
}

void gen_bmp_header_info(struct bmp_logo_info *bmp) {
	pr_info (
		"/*\n"
		" * This is auto generated by tool bmp_logo\n"
		" * If you don't know the details, don't edit it!\n"
		" */\n"
		"\n"
		"#ifndef __BMP_LOGO_HEADER_FILE__\n"
		"#define __BMP_LOGO_HEADER_FILE__\n"
		"\n"
		"#ifndef BMP_LOGO_INGO_STRUCT\n"
		"#define BMP_LOGO_INGO_STRUCT\n"
		"struct bmp_logo_info{\n"
		"	unsigned int type;\n"
		"	unsigned int compression;\n"
		"	unsigned int width;\n"
		"	int height;\n"
		"	unsigned int bitcount;\n"
		"	unsigned int nclrs;\n"
		"	unsigned int *palette;\n"
		"	unsigned char *databuffer;\n"
		"};\n"
		"#endif /* BMP_LOGO_INGO_STRUCT */\n"
		"\n"
		"extern struct bmp_logo_info bmp_logo;\n"
		"\n"
		"#endif /* __BMP_LOGO_HEADER_FILE__ */\n"
		);
}

void gen_bmp_data_info(struct bmp_logo_info *bmp) {
	int ii, jj, _height;
	unsigned int line_len;
	unsigned char *databuf;
	unsigned char *p;

	pr_info ( "/*\n"
			  " * This is auto generated by tool bmp_logo\n"
			  " * If you don't know the details, don't edit it!\n"
			  " */\n"
			  "\n"
			  "#ifndef __BMP_LOGO_DATA_FILE__\n"
			  "#define __BMP_LOGO_DATA_FILE__\n"
			  "\n"
			  "struct bmp_logo_info;\n"
			  "extern struct bmp_logo_info bmp_logo;\n"
			  "\n"
		);

	pr_info ( "static unsigned int bmp_palette_buffer[] = {\n");
	for ( ii = 0; ii < bmp->nclrs; ++ii) {
		if ((ii % 8) == 0)
			pr_info ("%c",'\t');
		pr_info ("0x%08X,%c", bmp->palette[ii], (ii % 8) == 7 ? '\n' : ' ');
	}

	pr_info ( "\n};\n"
			  "\n");

	pr_info ( "static unsigned char bmp_data_buffer[] = {\n");
	databuf = bmp->databuffer;
	line_len = to_line_len(bmp->width, bmp->bitcount);
	_height = bmp_height(bmp->height);
#if 1
	p = bmp->height > 0 ? databuf + (_height - 1) * line_len : databuf;
	for ( ii = 0; ii < _height; ++ii) {
		for (jj = 0; jj < line_len; ++jj) {
			if ((jj % 8) == 0)
				pr_info ("%c",'\t');
			pr_info ("0x%02X,%c", p[jj], (jj % 8) == 7 ? '\n' : ' ');
		}
		if (bmp->height > 0)
			p -= line_len;
		else
			p += line_len;
	}
#else
	for_each_bmp_line(bmp, p, ii, _height, line_len) {
		for (jj = 0; jj < line_len; ++jj) {
			if ((jj % 8) == 0)
				pr_info ("%c",'\t');
			pr_info ("0x%02X,%c", p[jj], (jj % 8) == 7 ? '\n' : ' ');
		}
	}
#endif

	pr_info ( "\n};\n"
			  "\n");

	pr_info ( "struct bmp_logo_info bmp_logo = {\n"
			  "	.type = 0x%x,\n"
			  "	.compression = 0x%x,\n"
			  "	.width = %u,\n"
			  "	.height = %d,\n"
			  "	.bitcount = %u,\n"
			  "	.nclrs = %u,\n"
			  "	.palette = bmp_palette_buffer,\n"
			  "	.databuffer = bmp_data_buffer,\n"
			  "};\n",
			  bmp->type,
			  bmp->compression,
			  bmp->width,
			  bmp->height,
			  bmp->bitcount,
			  bmp->nclrs
		);
	pr_info ( "\n"
			  "#endif /* __BMP_LOGO_DATA_FILE__ */\n"
		);
}

extern void bmp_to_color(struct bmp_logo_info *bmp, void *base, unsigned int bpp);

void gen_color_header_info(struct bmp_logo_info *bmp) {
	pr_info (  "/*\n"
			   " * This is auto generated by tool bmp_logo\n"
			   " * If you don't know the details, don't edit it!\n"
			   " */\n"
			   "\n"
			   "#ifndef __COLOR_MODE_HEADER_H__\n"
			   "#define __COLOR_MODE_HEADER_H__\n"
		);
	pr_info ( "#ifndef COLOR_MODE_STRUCT\n"
			  "#define COLOR_MODE_STRUCT\n"
			  "struct color_mode {\n"
			  "	unsigned int width;\n"
			  "	unsigned int height;\n"
			  "	unsigned int bpp;\n"
			  "	unsigned char base[0];\n"
			  "};\n"
			  "#endif /* COLOR_MODE_STRUCT */\n"
			  "\n"
			  "extern struct color_mode *logo_colors;\n"
		);

	pr_info ( "#endif /* __COLOR_MODE_HEADER_H__ */\n");
}

void gen_color_bin_info(struct bmp_logo_info *bmp) {
	struct color_mode *mode;
	unsigned int _height, width;

	_height = bmp_height(bmp->height);
	width = bmp->width;
	mode = (struct color_mode*)malloc(sizeof(struct color_mode) + _height * width * COLOR_BYTES);
	if (mode == NULL) {
		pr_err( "Failed to allocate color memory\n");
		return ;
	}

	mode->height = _height;
	mode->width = width;
	mode->bpp = COLOR_BYTES * 8;

	bmp_to_color(bmp, mode->base, mode->bpp);

	unsigned char *p;
	int i;
	p = (unsigned char *)mode;
	for (i = 0; i < sizeof(struct color_mode); ++i) {
		pr_info ("%c",*p);
		++p;
	}
	for (i = 0; i < mode->height * mode->width *COLOR_BYTES; ++i) {
		pr_info ("%c",mode->base[i]);
	}

	free(mode);
}

void gen_color_data_info(struct bmp_logo_info *bmp) {
	struct color_mode *mode;
	unsigned int _height, width;

	_height = bmp_height(bmp->height);
	width = bmp->width;
	mode = (struct color_mode*)malloc(sizeof(struct color_mode) + _height * width * COLOR_BYTES);
	if (mode == NULL) {
		pr_err( "Failed to allocate color memory\n");
		return ;
	}

	mode->height = _height;
	mode->width = width;
	mode->bpp = COLOR_BYTES * 8;

	bmp_to_color(bmp, mode->base, mode->bpp);

	pr_info ( "/*\n"
			  " * This is auto generated by tool bmp_logo\n"
			  " * If you don't know the details, don't edit it!\n"
			  " */\n"
			  "\n"
			  "#ifndef __COLOR_MODE_DATA_H__\n"
			  "#define __COLOR_MODE_DATA_H__\n"
			  "\n"
		);

	unsigned short *p16;
	unsigned int *p32;
	int i;
	switch (COLOR_BYTES) {
	case 2:
		pr_info ( "static unsigned short color_data[] = {\n");
		p16 = (unsigned short*)mode;
		pr_info ("%c",'\t');
		for (i = 0; i < sizeof(struct color_mode) / 2 ; ++i) {
			pr_info ("0x%04X, ", *p16);
			++p16;
		}
		pr_info ("\n");
		for (i = 0; i < _height * width ; ++i) {
			if ((i % 8) == 0)
				pr_info ("%c",'\t');
			pr_info ("0x%04X,%c", *p16, (i % 8) == 7 ? '\n' : ' ');
			++p16;
		}
		break;
	case 4:
		pr_info ( "static unsigned int color_data[] = {\n");
		p32 = (unsigned int*)mode;
		pr_info ("%c",'\t');
		for (i = 0; i < sizeof(struct color_mode) / 4; ++i) {
			pr_info ("0x%08X, ", *p32);
			++p32;
		}
		pr_info ("\n");
		for (i = 0; i < _height * width; ++i) {
			if ((i % 8) == 0)
				pr_info ("%c",'\t');
			pr_info ("0x%08X,%c", *p32, (i % 8) == 7 ? '\n' : ' ');
			++p32;
		}
		break;
	default:
		pr_err( "Could not support this color bytes:%u\n",COLOR_BYTES);
		break;
	}
	pr_info ( "\n"
			  "};\n"
		);

	pr_info ( "\n"
			  "struct color_mode *logo_colors = (struct color_mode *)color_data;\n"
			  "\n"
			  "#endif /* __COLOR_MODE_DATA_H__ */\n"
		);

	free(mode);
}
#endif	/* CONFIG_BMP_LOGO_AS_TOOL */

#define color32_red(color)   (((color) & 0x00ff0000) >> 16)
#define color32_green(color) (((color) & 0x0000ff00) >> 8)
#define color32_blue(color)  (((color) & 0x000000ff) >> 0)

#define color32_to_16(color)					\
	(((color32_red(color) >> 3) << 11) |		\
	 ((color32_green(color) >> 2) << 5) |		\
	 ((color32_red(color) >> 3) << 0) )

#define color16_red(color)  (((color) & 0xf800) >> 11)
#define color16_green(color) (((color) & 0x0fe0)>> 5)
#define color16_blue(color) (((color) & 0x1f) >> 0)

#define color16_to_32(color)					\
	((color16_red(color) << 16) |				\
	 (color16_green(color) << 8) |				\
	 (color16_blue(color) << 0))

void bmp_bits_to_color(struct bmp_logo_info *bmp, void *base, int bpp) {
	 int line_len;
	 int _height, width, bitcount;
	unsigned char *src;
	unsigned char *p;
	unsigned char bitsmask;
	unsigned int *palette;
	int i, j, k;
	unsigned int bitsvalue;
	unsigned int colorvalue;
	unsigned int *p32;
	unsigned short *p16;

	bitcount = bmp->bitcount;
	switch (bitcount) {
	case 1: bitsmask = 0x01; break;
	case 2: bitsmask = 0x03; break;
	case 4: bitsmask = 0x0F; break;
	case 8: bitsmask = 0xFF; break;
	default:
		pr_err( "Couldn't support this kind of bitcount:%x\n",bitcount);
		return;
	}

	_height = bmp_height(bmp->height);
	width = bmp->width;
	bitcount = bmp->bitcount;
	line_len = to_line_len(width, bitcount);
	palette = bmp->palette;

	src = bmp->height > 0 ? bmp->databuffer + (_height - 1) * line_len : bmp->databuffer;

	switch (bpp) {
	case 32: case 30: case 24: case 18:
		p32 = base;
		for_each_bmp_line(bmp, src, i, _height, line_len) {
			for (j = 0, p = src; ; ++p) {
				for (k = 8 - bitcount; k >= 0 ; k-=bitcount, ++j, ++p32) {
					if (!(j < width))
						goto next_line32;
					bitsvalue = (*p >> k) & bitsmask;
					colorvalue = palette[bitsvalue];
					*p32 = colorvalue;
				}
			}
		next_line32:
			;
		}
		break;
	case 16: case 15:
		p16 = base;
		for_each_bmp_line(bmp, src, i, _height, line_len) {
			for (j = 0, p = src; ; ++p) {
				for (k = 8 - bitcount; k >= 0 ; k-=bitcount, ++j, ++p16) {
					if (!(j < width))
						goto next_line16;
					bitsvalue = (*p >> k) & bitsmask;
					colorvalue = palette[bitsvalue];
					*p16 = color32_to_16(colorvalue);
				}
			}
		next_line16:
			;
		}
		break;
	default:
		pr_err( "Couldn't support this kind of bpp:%x\n", bpp);
		break;
	}
}

void bmp_bytes_to_color(struct bmp_logo_info *bmp, void *base, int bpp) {
	int line_len;
	int _height, width, bitcount;
	unsigned char *src;
	unsigned char *p;
	unsigned char *dest;
	int i, j, bytesnum;
	unsigned int *p32, *s32;
	unsigned short *p16, *s16;
	int _bpp;

	bitcount = bmp->bitcount;
	switch (bitcount) {
	case 16: bytesnum = 2; break;
	case 24: bytesnum = 3; break;
	case 32: bytesnum = 4; break;
	default:
		pr_err( "Couldn't support this kind of bitcount:%x\n",bitcount);
		return;
	}

	switch (bpp) {
	case 32: case 30: case 24: case 18:
		_bpp = 32; break;
	case 16: case 15:
		_bpp = 16; break;
	default:
		pr_err( "Couldn't support this kind of bpp:%x\n", bpp);
		return ;
	}

	_height = bmp_height(bmp->height);
	width = bmp->width;
	bitcount = bmp->bitcount;
	line_len = to_line_len(width, bitcount);
	p16 = base;
	p32 = base;

	s16 = (void *)bmp->databuffer;
	s32 = (void *)bmp->databuffer;
	src = bmp->height > 0 ? bmp->databuffer + (_height - 1) * line_len : bmp->databuffer;

	if ((_bpp == 16 && bitcount == 16) || (_bpp == 32 && bitcount == 32)) {
		dest = base;
		for_each_bmp_line(bmp, src, i, _height, line_len) {
			memcpy(dest, src, width * bytesnum);
			dest += width * bytesnum;
		}
	}  else if (_bpp == 16 && bitcount == 32) {
		p16 = base;
		for_each_bmp_line(bmp, src, i, _height, line_len) {
			for (j = 0, s32 = (unsigned int *)src; j < width; ++j, ++s32, ++p16) {
				*p16 = color32_to_16(*s32);
			}
		}
	} else if (_bpp == 16 && bitcount == 24) {
		p16 = base;
		for_each_bmp_line(bmp, src, i, _height, line_len) {
			for (j = 0, p = src; j < width; ++j, p += 3, ++p16) {
				*p16 = color32_to_16(*((unsigned int *)p));
			}
		}
	} else if (_bpp == 32 && bitcount == 16 ) {
		p32 = base;
		for_each_bmp_line(bmp, src, i, _height, line_len) {
			for (j = 0, s16 = (unsigned short*)src; j < width; ++j, ++s16, ++p32) {
				*p32 = color16_to_32(*s16);
			}
		}
	} else if (_bpp == 32 && bitcount == 24) {
		p32 = base;
		for_each_bmp_line(bmp, src, i, _height, line_len) {
			for (j = 0, p = src; j < width; ++j, p += 3, ++p32) {
				*p32 = p[0] + (p[1] << 8) + (p[2] << 16);
			}
		}
	}
}

#define bmp1_to_color(bmp, base, bpp) bmp_bits_to_color(bmp, base, bpp)
#define bmp2_to_color(bmp, base, bpp) bmp_bits_to_color(bmp, base, bpp)
#define bmp4_to_color(bmp, base, bpp) bmp_bits_to_color(bmp, base, bpp)
#define bmp8_to_color(bmp, base, bpp) bmp_bits_to_color(bmp, base, bpp)
#define bmp16_to_color(bmp, base, bpp) bmp_bytes_to_color(bmp, base, bpp)
#define bmp24_to_color(bmp, base, bpp) bmp_bytes_to_color(bmp, base, bpp)
#define bmp32_to_color(bmp, base, bpp) bmp_bytes_to_color(bmp, base, bpp)

void bmp_to_color(struct bmp_logo_info *bmp, void *base, unsigned int bpp) {
	unsigned int bitcount;

	bitcount = bmp->bitcount;
	switch (bitcount) {
	case 1:
		bmp1_to_color(bmp, base, bpp); break;
	case 2:
		bmp2_to_color(bmp, base, bpp); break;
	case 4:
		bmp4_to_color(bmp, base, bpp); break;
	case 8:
		bmp8_to_color(bmp, base, bpp); break;
	case 16:
		bmp16_to_color(bmp, base, bpp); break;
	case 24:
		bmp24_to_color(bmp, base, bpp); break;
	case 32:
		bmp32_to_color(bmp, base, bpp); break;
	default:
		pr_err( "Could not support this bitcount:%u\n",bitcount);
		return;
	}
}

int bmp_file_to_color_mode(void *file_buf, struct color_mode **colors) {
	struct bmp_logo_info *bmp;
	struct color_mode *new_colors;

	if (((unsigned char *)file_buf)[0] != 0 && ((unsigned char *)file_buf)[1] != 0) {
		bmp = bmp_deal_filebuffer(file_buf);
		if (bmp) {
			new_colors = bmp_to_color_mode(bmp, 4);
			if (new_colors) {
				if (*colors)
					free(*colors);
				*colors = new_colors;
				((unsigned char *)file_buf)[0] = 0;
				((unsigned char *)file_buf)[1] = 0;
				free_bmp(bmp);
				return 0;
			}
			free_bmp(bmp);
		}
	}

	return -1;
}

struct color_mode* bmp_to_color_mode(struct bmp_logo_info *bmp, unsigned int color_bytes) {
	struct color_mode*mode;

	mode = (struct color_mode*)malloc(sizeof(struct color_mode) +
			 bmp_height(bmp->height) * bmp->width * color_bytes);
	if (mode == NULL) {
		pr_err( "Failed to allocate color memory\n");
		return NULL;
	}

	mode->height = bmp_height(bmp->height);
	mode->width = bmp->width;
	mode->bpp = color_bytes * 8;

	bmp_to_color(bmp, mode->base, mode->bpp);

	return mode;
}

int bmp_file_to_fb_region(void *file_buf, struct fb_region **region) {
	struct bmp_logo_info *bmp;
	struct fb_region *new_region;

	if (((unsigned char *)file_buf)[0] != 0 && ((unsigned char *)file_buf)[1] != 0) {
		bmp = bmp_deal_filebuffer(file_buf);
		if (bmp) {
			new_region = bmp_to_fb_region(bmp, 4);
			if (new_region) {
				if (*region) {
					if ((*region)->base)
						free((*region)->base);
					free(*region);
				}
				*region = new_region;
				((unsigned char *)file_buf)[0] = 0;
				((unsigned char *)file_buf)[1] = 0;
				free_bmp(bmp);
				return 0;
			}
			free_bmp(bmp);
		}
	}

	return -1;
}

struct fb_region* bmp_to_fb_region(struct bmp_logo_info *bmp, unsigned int color_bytes) {
	struct fb_region *region;

	region = (struct fb_region *)malloc(sizeof(struct fb_region));
	if (region == NULL) {
		pr_err( "Failed to allocate region struct\n");
		return NULL;
	}

	region->base = malloc(bmp_height(bmp->height) * bmp->width * color_bytes);
	if (!region->base) {
		pr_err( "Failed to allocate region memory\n");
		free(region);
		return NULL;
	}
	region->yres = bmp_height(bmp->height);
	region->xres = bmp->width;
	region->bpp = color_bytes * 8;
	region->pixels_per_line = region->xres;

	bmp_to_color(bmp, region->base, region->bpp);

	return region;
}

struct bmp_logo_info* bmp_deal_filebuffer(void *filebuffer) {
	unsigned int type, filesize, dataoffset;
	int height;
	unsigned int infosize, width, bitcount, compression, clrused, clrimportant;

	fill_data(filebuffer, BF_TYPE_OFF, BF_TYPE_SIZE, &type);
	fill_data(filebuffer, BF_SIZE_OFF, BF_SIZE_SIZE, &filesize);
	fill_data(filebuffer, BF_OFFBITS_OFF, BF_OFFBITS_SIZE, &dataoffset);

	fill_data(filebuffer, BI_WIDTH_OFF, BI_WIDTH_SIZE, &width);
	fill_data(filebuffer, BI_HEIGHT_OFF, BI_HEIGHT_SIZE, (unsigned int *)&height);
	fill_data(filebuffer, BI_SIZE_OFF, BI_SIZE_SIZE, &infosize);
	fill_data(filebuffer, BI_BITCOUNT_OFF, BI_BITCOUNT_SIZE, &bitcount);
	fill_data(filebuffer, BI_COMPRESSION_OFF, BI_COMPRESSION_SIZE, &compression);
	fill_data(filebuffer, BI_CLRUSED_OFF, BI_CLRUSED_SIZE, &clrused);
	fill_data(filebuffer, BI_CLRIMPORTANT_OFF, BI_CLRIMPORTANT_SIZE, &clrimportant);

	if (!type_supported(type)) {
		pr_err( "Can't support such type:\"%c%c(0x%x)\"\n",type % 256, type / 256, type);
		return NULL;
	}
	if (!compression_supported(compression)) {
		pr_err( "Can't support such compression method:0x%x\n",compression);
		return NULL;
	}
	if (!info_supported(infosize)) {
		pr_err( "Can't support this info header with this size:0x%x\n",infosize);
		return NULL;
	}

	struct bmp_logo_info *bmp;

	bmp = malloc(sizeof(struct bmp_logo_info));
	if (bmp == NULL) {
		pr_err( "Failed to allocate bmp logo info struct");
		return NULL;
	}

	BF_PALETTE_OFF = BF_FILEHEADER_SIZE + infosize;
	BF_PALETTE_SIZE = dataoffset - BF_PALETTE_OFF;

	bmp->type = type;
	bmp->compression = compression;
	bmp->width = width;
	bmp->height = height;
	bmp->bitcount = bitcount;
	bmp->nclrs = clrused > clrimportant ? clrused : clrimportant;
	bmp->nclrs = (bmp->nclrs == 0 ? BF_PALETTE_SIZE / 4 : bmp->nclrs);
#if CONFIG_BMP_DATA_ALLOCATE
	bmp->palette = (unsigned int *)malloc(BF_PALETTE_SIZE);
	if (bmp->palette == NULL) {
		pr_err( "Failed to allocate bmp palette buffer\n");
		return NULL;
	}
	memcpy(bmp->palette, (char *)filebuffer + BF_PALETTE_OFF, BF_PALETTE_SIZE);
#else
	bmp->palette = (unsigned int *)(filebuffer + BF_PALETTE_OFF);
#endif
#if CONFIG_BMP_DATA_ALLOCATE
	int ii,  _height;
	unsigned int line_len;
	unsigned char *databuf;
	unsigned char *dest;
	unsigned char *src;

	bmp->databuffer = (unsigned char *)malloc(filesize - dataoffset);
	if (bmp->databuffer == NULL) {
		pr_err( "Failed to allocate bmp data buffer\n");
		return NULL;
	}
	databuf = (unsigned char *)filebuffer + dataoffset;
	line_len = to_line_len(bmp->width, bmp->bitcount);
	_height = bmp_height(bmp->height);
	/*For bmp file
	 *   if height > 0 , the data store order is From down to up, left to right
	 *      height < 0 , the data store order is From up to down, left to right.
	 *
	 * we want the data suite for the store oder of framebuffer
	 *     From up to down, left to right.
	 */
	src = bmp->height > 0 ? databuf + (_height - 1) * line_len : databuf;
	dest = bmp->databuffer;
	for ( ii = 0; ii < _height; ++ii) {
		memcpy(dest, src, line_len);
		if (bmp->height > 0)
			src -= line_len;
		else
			src += line_len;
		dest += line_len;
	}
	/* So we have a Negative bmp height (heigt < 0) */
	bmp->height = 0 - bmp_height(bmp->height);
#else
	bmp->databuffer = filebuffer + dataoffset;
#endif

	return bmp;
}

void free_bmp(struct bmp_logo_info *bmp) {
	if (bmp) {
#if CONFIG_BMP_DATA_ALLOCATE
		free(bmp->palette);
		free(bmp->databuffer);
#endif
		free(bmp);
	}
}

#if BMP_SUPPORT_FILE_OP
struct bmp_logo_info* bmp_deal_file(char *filename){
	FILE *fp;
	struct bmp_logo_info *bmp = NULL;

	fp = fopen(filename, "rb");
	if (fp == NULL) {
		pr_err( "Failed to open file \"%s\"\n",filename);
		return NULL;
	}

	char type1, type2;
	type1 = fgetc(fp);
	type2 = fgetc(fp);
	if (type1 != 'B' || type2 != 'M') {
		pr_err( "Don't support this kind of bmp file:\"%c%c\"\n",type1, type2);
		goto close_file;
	}

	unsigned int file_len = 0;
	if (fread(&file_len, BF_SIZE_SIZE, 1, fp) != 1) {
		pr_err( "Couldn't read bmp file size\n");
		goto close_file;
	}

	char *filebuffer;
	filebuffer = (char *)malloc(file_len);
	if (filebuffer == NULL) {
		pr_err( "Failed to allocate the file buffer\n");
		goto close_file;
	}

	fseek(fp, 0, SEEK_SET);
	if (fread(filebuffer, file_len, 1, fp) != 1) {
		pr_err( "Couldn't read the whole bmp file\n");
		goto free_buffer;
	}

	/*
	 * This should not be exist, but I want copy the bmp_deal_filebuffer() to another place.
	 */
	bmp = bmp_deal_filebuffer(filebuffer);
#ifdef CONFIG_BMP_LOGO_AS_TOOL
	/* gen basic hexl info */
	if (gen_basic_hex) {
		gen_basic_hex_info(filebuffer);
	}

	/* gen bmp filebuffer */
	if (gen_bmp_filebuffer){
		gen_bmp_filebuffer_info(filebuffer, file_len);
	}

	/* gen bmp header info */
	if (gen_bmp_header)
		gen_bmp_header_info(bmp);

	/* gen bmp data info */
	if (gen_bmp_data)
		gen_bmp_data_info(bmp);

	/* gen color bin file */
	if (gen_color_bin)
		gen_color_bin_info(bmp);

	/* gen color header info */
	if (gen_color_header)
		gen_color_header_info(bmp);

	/* gen color data info */
	if (gen_color_data)
		gen_color_data_info(bmp);
#endif

free_buffer:
	free(filebuffer);
close_file:
	fclose(fp);

	return bmp;
}

int main (int argc, char *argv[]) {
	int i;
	int invalid_args = 0;
	int have_file = 0;

	if (argc <= 1) {
		return usage(argv[0]);
	}

	for (i = 1 ; i < argc; ++i) {
		if (!strcmp("--gen-bmp-header", argv[i]) || !strcmp("-gen-bmp-header", argv[i]))
			gen_bmp_header = 1;
		else if (!strcmp("--gen-bmp-data", argv[i]) || !strcmp("-gen-bmp-data", argv[i]))
			gen_bmp_data = 1;
		else if (!strcmp("--gen-color-bin", argv[i]) || !strcmp("-gen-color-bin", argv[i]))
			gen_color_bin = 1;
		else if (!strcmp("--gen-color-header", argv[i]) || !strcmp("-gen-color-header", argv[i]))
			gen_color_header = 1;
		else if (!strcmp("--gen-color-data", argv[i]) || !strcmp("-gen-color-data", argv[i]))
			gen_color_data = 1;
		else if (!strcmp("--gen-basic-hex", argv[i]) || !strcmp("-gen-basic-hex", argv[i]))
			gen_basic_hex = 1;
		else if (!strcmp("--gen-bmp-filebuffer", argv[i]) || !strcmp("-gen-bmp-filebuffer", argv[i]))
			gen_bmp_filebuffer = 1;
		else if (!strcmp("--color=16", argv[i]) || !strcmp("-color=16", argv[i]))
			COLOR_BYTES = 2;
		else if (!strcmp("--color=32", argv[i]) || !strcmp("-color=32", argv[i]))
			COLOR_BYTES = 4;
		else if (argv[i][0] == '-'){
			pr_err( "Unrecognised option:%s\n",argv[i]);
			invalid_args = 1;
		} else {
			have_file = 1;
			/* treat it as filename */
		}
	}
	if (invalid_args == 1) {
		return usage(argv[0]);
	}
	if (have_file == 0) {
		pr_err( "At least one filename should be specified!!!\n");
		return usage(argv[0]);
	}

	if (gen_bmp_header == 0 && gen_bmp_data == 0 &&
		gen_color_bin == 0 && gen_color_header == 0 && gen_color_data == 0 &&
		gen_bmp_filebuffer == 0) {
		gen_basic_hex = 1;
	}
	if ((gen_color_bin == 1) &&
		(gen_basic_hex == 1 || gen_bmp_filebuffer == 1 ||
		 gen_bmp_header == 1 || gen_bmp_data == 1 ||
		 gen_color_header == 1 || gen_color_data == 1)) {
		pr_err( "I don't think it is a good choice to make the --gen-color-bin with any other option together\n");
		return -1;
	}

	struct bmp_logo_info *bmp = NULL;

	for (i = 1; i < argc; ++i) {
		if (argv[i][0] != '-') {
			bmp = bmp_deal_file(argv[i]);
			free_bmp(bmp);
		}
	}

	return 0;
}
#endif	/* BMP_SUPPORT_FILE_OP */
